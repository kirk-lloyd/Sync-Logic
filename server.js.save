import dotenv from 'dotenv';
dotenv.config();
import express from 'express';
import bodyParser from 'body-parser';
import crypto from 'crypto';
import path from 'path';
import axios from 'axios';
import cors from 'cors';
import cookieParser from 'cookie-parser';
import session from 'express-session';
import { fileURLToPath } from 'url';

// Import models
import Store from './models/store.model.js';

// Import routes
import productRoutes from './routes/product.routes.js';
import storeRoutes from './routes/store.routes.js';

// Import the initializeDatabase function from connect.js
import { initializeDatabase } from './db/connect.js';

// Create __dirname equivalent for ES Modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

console.log('Starting server initialization...');

// Initialize the database connection
initializeDatabase().then(() => {
  console.log('Database initialization complete.');
}).catch((error) => {
  console.error('Error during database initialization:', error);
});

const app = express();
const port = process.env.PORT || 3000;

// Shopify credentials from environment variables
const SHOPIFY_API_KEY = process.env.SHOPIFY_API_KEY;
const SHOPIFY_API_SECRET = process.env.SHOPIFY_API_SECRET;

// Middleware setup
console.log('Setting up middleware...');
app.use(cors({
  origin: process.env.ALLOWED_ORIGINS || 'https://your-shopify-app-url.com',
  credentials: true
}));
console.log('CORS middleware setup complete.');

app.use(bodyParser.json({
  verify: (req, res, buf) => {
    req.rawBody = buf;
  }
}));
console.log('Body parser setup complete.');

app.use(cookieParser());
console.log('Cookie parser setup complete.');

app.use(session({
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  cookie: { secure: process.env.NODE_ENV === 'production' }
}));
console.log('Session middleware setup complete.');

// Log every incoming request
app.use((req, res, next) => {
  console.log(`Incoming request: ${req.method} ${req.url}`);
  next();
});

// Middleware to verify Shopify webhook authenticity
function verifyWebhook(req, res, next) {
  console.log('Verifying webhook...');
  try {
    const hmacHeader = req.headers['x-shopify-hmac-sha256'];
    const secret = SHOPIFY_API_SECRET;
    const hash = crypto.createHmac('sha256', secret).update(req.rawBody).digest('base64');

    const isVerified = crypto.timingSafeEqual(Buffer.from(hash), Buffer.from(hmacHeader));
    if (isVerified) {
      console.log('Webhook verification successful.');
      next();
    } else {
      console.error('Webhook verification failed. Possible unauthorized access attempt.');
      res.status(401).send('Unauthorized');
    }
  } catch (error) {
    console.error('Error in webhook verification:', error);
    res.status(500).send('Internal Server Error');
  }
}

// Handle App Uninstallation
app.post('/webhooks/app/uninstalled', verifyWebhook, async (req, res) => {
  console.log('Processing app/uninstalled webhook...');
  const shopDomain = req.headers['x-shopify-shop-domain'];
  try {
    await Store.findOneAndDelete({ shop_domain: shopDomain });
    console.log(`Data for ${shopDomain} removed upon app uninstall.`);
    res.status(200).send('App uninstalled');
  } catch (error) {
    console.error('Error handling app/uninstalled webhook:', error);
    res.status(500).send('Internal Server Error');
  }
});

// OAuth Callback Route
app.get('/auth/callback', async (req, res) => {
  console.log('Handling OAuth callback...');
  const { shop, code, hmac, state, ...rest } = req.query;

  if (!shop || !code || !hmac || !state) {
    console.error('Missing required parameters in OAuth callback.');
    return res.status(400).send("Required parameters missing");
  }

  console.log('OAuth callback parameters received:', req.query);

  // Construct the message for HMAC validation by sorting query parameters
  const queryParams = { ...rest, shop, code, state };
  const sortedQuery = Object.keys(queryParams)
    .sort()
    .map((key) => `${key}=${queryParams[key]}`)
    .join('&');

// Generate HMAC using the sorted query string and the SHOPIFY_API_SECRET
const hmacFromShopify = req.query.hmac;
delete req.query.hmac;

const message = querystring.stringify(req.query, '&', '=', {
  encodeURIComponent: querystring.unescape,
});
const calculatedHmac = crypto
  .createHmac('sha256', process.env.SHOPIFY_API_SECRET)
  .update(message)
  .digest('hex');

if (calculatedHmac !== hmacFromShopify) {
  console.error('HMAC validation failed during OAuth callback.');
  return res.status(400).send("HMAC validation failed");
}

  // Request the access token from Shopify
  const accessTokenRequestUrl = `https://${shop}/admin/oauth/access_token`;
  const accessTokenPayload = {
    client_id: SHOPIFY_API_KEY,
    client_secret: SHOPIFY_API_SECRET,
    code,
  };

  try {
    console.log('Requesting access token from Shopify...');
    const response = await axios.post(accessTokenRequestUrl, accessTokenPayload);
    if (response.data && response.data.access_token) {
      const accessToken = response.data.access_token;

      console.log('Access token received. Saving to database...');
      // Save or update shop and access token in the unique store database
      const storeData = { shop_domain: shop, access_token: accessToken };
      const updatedStore = await Store.findOneAndUpdate(
        { shop_domain: shop },
        storeData,
        { upsert: true, new: true }
      );

      if (updatedStore) {
        console.log(`Successfully stored access token in MongoDB for ${shop}`);
      } else {
        console.error(`Failed to save access token for ${shop} in MongoDB`);
      }

      // Create metafields for the store using the access token
      const metafieldsUrl = `https://${shop}/admin/api/2023-04/metafields.json`;
      const metafields = [
        {
          namespace: `custom_namespace_${shop}`,
          key: "stock_sync_master",
          value: false,
          type: "boolean"
        },
        {
          namespace: `custom_namespace_${shop}`,
          key: "linked_products",
          value: "",
          type: "list"
        }
      ];

      for (const metafieldPayload of metafields) {
        try {
          console.log(`Handling metafield ${metafieldPayload.key} for ${shop}`);
          // Check if the metafield already exists
          const existingMetafields = await axios.get(metafieldsUrl, {
            headers: {
              'X-Shopify-Access-Token': accessToken,
              'Content-Type': 'application/json'
            },
            params: {
              namespace: metafieldPayload.namespace,
              key: metafieldPayload.key
            }
          });

          if (existingMetafields.data.metafields.length === 0) {
            console.log(`Creating metafield ${metafieldPayload.key} for ${shop}`);
            await axios.post(metafieldsUrl, { metafield: metafieldPayload }, {
              headers: {
                'X-Shopify-Access-Token': accessToken,
                'Content-Type': 'application/json'
              }
            });
            console.log(`Metafield ${metafieldPayload.key} created for ${shop}`);
          } else {
            console.log(`Metafield ${metafieldPayload.key} already exists for ${shop}, skipping creation.`);
          }
        } catch (error) {
          console.error(`Error handling metafield ${metafieldPayload.key} for ${shop}:`, error);
          res.status(500).send('Error handling metafield creation');
          return;
        }
      }

      // Redirect back to the app within the Shopify admin
      console.log('Redirecting to Shopify app...');
      res.redirect(`https://${shop}/admin/apps/${process.env.SHOPIFY_APP_HANDLE}`);
    } else {
      console.error("Access token missing in Shopify response:", response.data);
      return res.status(500).send("Access token missing in response");
    }
  } catch (error) {
    console.error("Error during OAuth callback:", error.message);
    res.status(500).send("Internal Server Error");
  }
});

// Use imported routes
app.use('/api/products', (req, res, next) => {
  console.log('Accessing /api/products route...');
  next();
}, productRoutes);

app.use('/api/stores', (req, res, next) => {
  console.log('Accessing /api/stores route...');
  next();
}, storeRoutes);

// Serve static files from the React app
console.log("Serving static files from the 'public' directory.");
app.use(express.static(path.join(__dirname, 'public')));

// Serve React App for any unknown routes
app.get('*', (req, res) => {
  console.log('Fallback route triggered, serving React app...');
  res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// Start the Express server
app.listen(port, () => {
  console.log(`Server is running at http://localhost:${port}`);
});
